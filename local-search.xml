<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Gin框架学习</title>
    <link href="/2022/02/08/Gin%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/02/08/Gin%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>前言：之前在QQ音乐实习的时候，一直用的是TEG那边写的going框架+TME在此基础上的封装，一直没能目睹Gin框架的真容，目前IEG所在组用的是Gin，正好学习一下优秀开源框架的设计思想，故记录此文</p><p><a href="https://gin-gonic.com/">https://gin-gonic.com/</a></p></blockquote><h1 id="Gin框架学习"><a href="#Gin框架学习" class="headerlink" title="Gin框架学习"></a>Gin框架学习</h1><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default()<br>r.GET(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;pong&quot;</span>,<br>&#125;)<br>&#125;)<br>r.Run() <span class="hljs-comment">// listen and serve on 0.0.0.0:8080</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-Gin-Middleware"><a href="#1-Gin-Middleware" class="headerlink" title="1. Gin Middleware"></a>1. Gin Middleware</h3><p>在学习项目源码的过程中，看到大量使用了中间件，比如统计某接口的耗时，进行登陆态校验，开启跨域函数等等，那么这个中间件是个什么东西？</p><h4 id="Middleware-support"><a href="#Middleware-support" class="headerlink" title="Middleware support"></a>Middleware support</h4><blockquote><p>An incoming HTTP request can be handled by a chain of middlewares and the final action. For example: Logger, Authorization, GZIP and finally post a message in the DB.</p></blockquote><p>从Gin的官网介绍大概能得知中间件是一个可以处理HTTP请求的函数调用链，这类似与Java中的Filter过滤器或者是Spring中的Interceptor拦截器，可以统一在请求接口之前或之后执行我们定义的中间件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// HandlerFunc defines the handler used by gin middleware as return value.</span><br><span class="hljs-keyword">type</span> HandlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Context)</span></span><br><br><span class="hljs-comment">// HandlersChain defines a HandlerFunc array.</span><br><span class="hljs-keyword">type</span> HandlersChain []HandlerFunc<br></code></pre></td></tr></table></figure><h4 id="用例Demo"><a href="#用例Demo" class="headerlink" title="用例Demo"></a>用例Demo</h4><p>了解了基本的概念之后，如何使用？开发文档提供了如下Demo</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Logger</span><span class="hljs-params">()</span> <span class="hljs-title">gin</span>.<span class="hljs-title">HandlerFunc</span></span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>t := time.Now()<br><span class="hljs-comment">// Set example variable</span><br>c.Set(<span class="hljs-string">&quot;example&quot;</span>, <span class="hljs-string">&quot;12345&quot;</span>)<br><span class="hljs-comment">// before request</span><br><br>c.Next()<br><br><span class="hljs-comment">// after request</span><br>latency := time.Since(t)<br>log.Print(latency)<br><span class="hljs-comment">// access the status we are sending</span><br>status := c.Writer.Status()<br>log.Println(status)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.New()<br>r.Use(Logger()) <span class="hljs-comment">// 注册中间件</span><br>r.GET(<span class="hljs-string">&quot;/test&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;  <span class="hljs-comment">// 注册/test接口对应的执行方法</span><br>example := c.MustGet(<span class="hljs-string">&quot;example&quot;</span>).(<span class="hljs-keyword">string</span>)<br><span class="hljs-comment">// it would print: &quot;12345&quot;</span><br>log.Println(example)<br>&#125;)<br><span class="hljs-comment">// Listen and serve on 0.0.0.0:8080</span><br>r.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl --location --request GET &#x27;http://localhost:8080/test&#x27;<br>2022/01/26 17:38:34 12345<br>2022/01/26 17:38:34 140.807µs<br>2022/01/26 17:38:34 200<br></code></pre></td></tr></table></figure><p>可以看到，在注册了<code>Logger()</code>中间件后，依次是打印了<code>example</code>、<code>latency</code>和<code>status</code>三个变量的值。</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Use attaches a global middleware to the router. ie. the middleware attached though Use() will be</span><br><span class="hljs-comment">// included in the handlers chain for every single request. Even 404, 405, static files...</span><br><span class="hljs-comment">// For example, this is the right place for a logger or error management middleware.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span> <span class="hljs-title">Use</span><span class="hljs-params">(middleware ...HandlerFunc)</span> <span class="hljs-title">IRoutes</span></span> &#123;<br>engine.RouterGroup.Use(middleware...)<br>engine.rebuild404Handlers()<br>engine.rebuild405Handlers()<br><span class="hljs-keyword">return</span> engine<br>&#125;<br><br><span class="hljs-comment">// Use adds middleware to the group, see example code in GitHub.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span> <span class="hljs-title">Use</span><span class="hljs-params">(middleware ...HandlerFunc)</span> <span class="hljs-title">IRoutes</span></span> &#123;<br>group.Handlers = <span class="hljs-built_in">append</span>(group.Handlers, middleware...) <span class="hljs-comment">// 将多个中间件添加到group.Handlers也就是slice中</span><br><span class="hljs-keyword">return</span> group.returnObj()<br>&#125;<br><br><span class="hljs-comment">// RouterGroup is used internally to configure router, a RouterGroup is associated with</span><br><span class="hljs-comment">// a prefix and an array of handlers (middleware).</span><br><span class="hljs-keyword">type</span> RouterGroup <span class="hljs-keyword">struct</span> &#123;<br>Handlers HandlersChain<br>basePath <span class="hljs-keyword">string</span><br>engine   *Engine<br>root     <span class="hljs-keyword">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，<code>Use()</code>将多个中间件函数注册到RouterGroup这个结构体中的HandlersChain slice中</p><p>再来看<code>Get()</code>是如何执行并访问到注册的接口的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// GET is a shortcut for router.Handle(&quot;GET&quot;, path, handle).</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span> <span class="hljs-title">GET</span><span class="hljs-params">(relativePath <span class="hljs-keyword">string</span>, handlers ...HandlerFunc)</span> <span class="hljs-title">IRoutes</span></span> &#123;<br><span class="hljs-keyword">return</span> group.handle(http.MethodGet, relativePath, handlers)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span> <span class="hljs-title">handle</span><span class="hljs-params">(httpMethod, relativePath <span class="hljs-keyword">string</span>, handlers HandlersChain)</span> <span class="hljs-title">IRoutes</span></span> &#123;<br>absolutePath := group.calculateAbsolutePath(relativePath) <span class="hljs-comment">// 绝对地址</span><br>handlers = group.combineHandlers(handlers) <span class="hljs-comment">// 将注册的func合并到HandlersChain中</span><br>group.engine.addRoute(httpMethod, absolutePath, handlers)<br><span class="hljs-keyword">return</span> group.returnObj()<br>&#125;<br><br><span class="hljs-keyword">const</span> abortIndex <span class="hljs-keyword">int8</span> = math.MaxInt8 / <span class="hljs-number">2</span> <span class="hljs-comment">// =63</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span> <span class="hljs-title">combineHandlers</span><span class="hljs-params">(handlers HandlersChain)</span> <span class="hljs-title">HandlersChain</span></span> &#123;<br>finalSize := <span class="hljs-built_in">len</span>(group.Handlers) + <span class="hljs-built_in">len</span>(handlers) <span class="hljs-comment">// HandlersChain已有的HandlerFunc + 当前要添加的HandlerFunc的长度大于最大长度则panic</span><br><span class="hljs-keyword">if</span> finalSize &gt;= <span class="hljs-keyword">int</span>(abortIndex) &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;too many handlers&quot;</span>)<br>&#125;<br>mergedHandlers := <span class="hljs-built_in">make</span>(HandlersChain, finalSize)<br><span class="hljs-built_in">copy</span>(mergedHandlers, group.Handlers) <span class="hljs-comment">// copy原有的HandlerFunc到新的slice mergedHandlers</span><br><span class="hljs-built_in">copy</span>(mergedHandlers[<span class="hljs-built_in">len</span>(group.Handlers):], handlers) <span class="hljs-comment">// copy新增的HandlerFunc</span><br><span class="hljs-keyword">return</span> mergedHandlers<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，在像Demo中调用的那样之后，HandlersChain 会形成这样一个Slice，里面的HandlerFunc是依次顺序执行的。</p><p><img src="/img/Gin%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/image-20220126195307202.png"></p><p>再来看<code>Next()</code>，实现原理很简单，首先是index指针自增1，随后进入一个死循环，依次执行HandlersChain Slice中的下一个HandlerFunc直到最后</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Next should be used only inside middleware.</span><br><span class="hljs-comment">// It executes the pending handlers in the chain inside the calling handler.</span><br><span class="hljs-comment">// See example in GitHub.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span> <span class="hljs-title">Next</span><span class="hljs-params">()</span></span> &#123;<br>c.index++<br><span class="hljs-keyword">for</span> c.index &lt; <span class="hljs-keyword">int8</span>(<span class="hljs-built_in">len</span>(c.handlers)) &#123; <span class="hljs-comment">// 死循环</span><br>c.handlers[c.index](c) <span class="hljs-comment">// 执行HandlersChain Slice中下一个HandlerFunc</span><br>c.index++<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以Demo中代码首先执行<code>Logger()</code>，在设置完example中的值之后调用了<code>Next()</code>从而执行main.main.func1，最后再回到main.Logger.func1执行3和4</p><p><img src="/img/Gin%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/image-20220126195826399.png" alt="image-20220126195826399"></p><h4 id="踩坑点"><a href="#踩坑点" class="headerlink" title="踩坑点"></a>踩坑点</h4><p>需要注意的是，<code>Use()</code>需要在<code>Get() Post()...</code>之类的方法之前调用，否则HandlersChain中只会有<code>Use()</code>添加的中间件而不会有<code>Get() Post()...</code>添加的接口执行函数，因为只有在<code>handle()</code>方法中才会进行HandlersChain的copy和append</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.New()<br>r.Use(TimeExpend)<br>r.GET(<span class="hljs-string">&quot;/ping&quot;</span>, f1, process, f2, f3)<br>r.Run() <span class="hljs-comment">// listen and serve on 0.0.0.0:8080 (for windows &quot;localhost:8080&quot;)</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TimeExpend</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>t := time.Now()<br>c.Next()<br>fmt.Println(time.Since(t))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">process</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;process&quot;</span>)<br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;pong&quot;</span>,<br>&#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f1</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;f1&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f2</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;f2&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f3</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;f3&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 执行链条 TimeExpend记录开始时间-&gt;f1-&gt;process-&gt;f2-&gt;f3-&gt;TimeExpend打印耗时</span><br><span class="hljs-comment">// 输出结果:</span><br><span class="hljs-comment">// f1</span><br><span class="hljs-comment">// process</span><br><span class="hljs-comment">// f2</span><br><span class="hljs-comment">// f3</span><br><span class="hljs-comment">// 106.441µs</span><br></code></pre></td></tr></table></figure><p><img src="/img/Gin%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/image-20220126224500983.png" alt="image-20220126224500983"></p><h3 id="2-Gin-路由树"><a href="#2-Gin-路由树" class="headerlink" title="2. Gin 路由树"></a>2. Gin 路由树</h3><p>TODO</p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang并发浅析</title>
    <link href="/2022/01/30/Golang%E5%B9%B6%E5%8F%91%E6%B5%85%E6%9E%90/"/>
    <url>/2022/01/30/Golang%E5%B9%B6%E5%8F%91%E6%B5%85%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<blockquote><p>前言：最近在看学习go channel相关的设计，看了许多博文，感觉知识点还是比较零散，同时极大的感受到，输入的知识点是输出的基础，输入的知识点是低质量的，输出也只能是管中窥豹，所以还是要看官方文档和视频，学习在于输出而不在入呀，遂记录一下学习笔记和心得~</p></blockquote><h1 id="Golang-并发浅析"><a href="#Golang-并发浅析" class="headerlink" title="Golang 并发浅析"></a>Golang 并发浅析</h1><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><h3 id="Why-Channel"><a href="#Why-Channel" class="headerlink" title="Why Channel"></a>Why Channel</h3><p>在Golang诞生之前，各编程语言都使用多线程进行编程，像笔者之前使用的Java，多线程操作比较复杂、混乱、难以管理，以至于笔者在开发过程中几乎不用多线程操作。</p><p>Golang是Google为了解决高并发搜索而设计的，它们想使用简单的方式，高效解决并发问题。</p><blockquote><p>Concurrency is the key to designing high performance network services. Go’s concurrency primitives (goroutines and channels) provide a simple and efficient means of expressing concurrent execution. In this talk we see how tricky concurrency problems can be solved gracefully with simple Go code.</p><p><a href="https://golang.org/doc/#go_concurrency_patterns">https://golang.org/doc/#go_concurrency_patterns</a></p></blockquote><p>在go开发中有一句至理名言，不要用共享内存来通信，相反，要用通信来共享内存。go语言中的协程goroutine之间的通信就是通过channel来实现的</p><blockquote><p>Do not communicate by sharing memory; instead, share memory by communicating.</p></blockquote><p>也就是说channel是实现不同goroutine之间通信的方式</p><p><img src="/img/Golang%E5%B9%B6%E5%8F%91%E6%B5%85%E6%9E%90/image-20220129153903870.png" alt="image-20220129153903870"></p><h3 id="Channel的设计"><a href="#Channel的设计" class="headerlink" title="Channel的设计"></a>Channel的设计</h3><p>Channel的底层是由runtime.hchan定义的，本质上就是一个有锁的队列，数据经过channel在两个goroutine之间流动：</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> hchan <span class="hljs-keyword">struct</span> &#123;<br>    qcount   <span class="hljs-keyword">uint</span>           <span class="hljs-comment">// 队列中数据个数</span><br>    dataqsiz <span class="hljs-keyword">uint</span>           <span class="hljs-comment">// channel 大小</span><br>    buf      unsafe.Pointer <span class="hljs-comment">// 指向存放数据的环形数组的指针</span><br>    elemsize <span class="hljs-keyword">uint16</span>         <span class="hljs-comment">// channel 中数据类型的大小</span><br>    closed   <span class="hljs-keyword">uint32</span>         <span class="hljs-comment">// 表示 channel 是否关闭</span><br>    elemtype *_type <span class="hljs-comment">// 元素数据类型</span><br>    sendx    <span class="hljs-keyword">uint</span>   <span class="hljs-comment">// 存放数据环形数组的发送索引</span><br>    recvx    <span class="hljs-keyword">uint</span>   <span class="hljs-comment">// 存放数据环形数组的接收索引</span><br>    recvq    waitq  <span class="hljs-comment">// 由 recv 行为（也就是 &lt;-ch）阻塞在 channel 上的 goroutine 队列</span><br>    sendq    waitq  <span class="hljs-comment">// 由 send 行为 (也就是 ch&lt;-) 阻塞在 channel 上的 goroutine 队列</span><br><br>    <span class="hljs-comment">// lock protects all fields in hchan, as well as several</span><br>    <span class="hljs-comment">// fields in sudogs blocked on this channel.</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// Do not change another G&#x27;s status while holding this lock</span><br>    <span class="hljs-comment">// (in particular, do not ready a G), as this can deadlock</span><br>    <span class="hljs-comment">// with stack shrinking.</span><br>    lock mutex<br>&#125;<br><br><span class="hljs-keyword">type</span> waitq <span class="hljs-keyword">struct</span> &#123;<br>first *sudog<br>last  *sudog<br>&#125;<br><br><span class="hljs-keyword">type</span> sudog <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// The following fields are protected by the hchan.lock of the</span><br><span class="hljs-comment">// channel this sudog is blocking on. shrinkstack depends on</span><br><span class="hljs-comment">// this for sudogs involved in channel ops.</span><br>g *g <span class="hljs-comment">// 关联的goroutine</span><br><br>next *sudog <span class="hljs-comment">// 形成一个双向FIFO队列</span><br>prev *sudog<br>elem unsafe.Pointer <span class="hljs-comment">// data element (may point to stack)</span><br>...<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/img/Golang%E5%B9%B6%E5%8F%91%E6%B5%85%E6%9E%90/image-20220129153951094.png" alt="image-20220129153951094"></p><p>在调用make方法创建Channel的过程中，会在堆中创建实例对象并返回指针：</p><p><img src="/img/Golang%E5%B9%B6%E5%8F%91%E6%B5%85%E6%9E%90/image-20220129163457648.png" alt="image-20220129163457648"></p><h3 id="Channel的特性"><a href="#Channel的特性" class="headerlink" title="Channel的特性"></a>Channel的特性</h3><ul><li>通过互斥锁mutex实现goroutine-safe，多个 goroutine 可以同时访问一个 channel，并且是协程安全的。</li><li>通过循环队列实现先入先出（FIFO）</li><li>可以用在不同的goroutine间传递数据，并且是通过仅共享hchan ＋ 数据拷贝实现的。</li><li>可以导致 goroutine 的 block 和 unblock，channel的阻塞是通过goroutine自己挂起，唤醒goroutine是通过对方goroutine唤醒实现的。</li><li>发送goroutine是可以访问接收goroutine的内存空间的，接收goroutine也是可以直接访问发送goroutine的内存空间。</li><li>无缓冲的channel始终都是直接访问对方goroutine内存的方式，把手伸到别人的内存，把数据放到接收变量的内存，或者从发送goroutine的内存拷贝到自己内存。省掉了对方再加锁获取数据的过程</li><li>接收goroutine当channel关闭时，读channel会得到0值，并不是channel保存了0值，而是它发现channel关闭了，把接收数据的变量的值设置为0值。</li></ul><h3 id="使用Channel-Demo"><a href="#使用Channel-Demo" class="headerlink" title="使用Channel Demo"></a>使用Channel Demo</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> numWorkers = <span class="hljs-number">10</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 带缓冲的channel</span><br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Task, numWorkers)<br><br><span class="hljs-comment">// 启动固定数量的worker</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; numWorkers; i++ &#123;<br><span class="hljs-keyword">go</span> worker(ch)<br>&#125;<br><br><span class="hljs-comment">// 1秒生产一次任务并发送给worker</span><br>i := <span class="hljs-number">1</span><br>tick := time.Tick(<span class="hljs-number">1</span> * time.Second)<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-tick:<br><span class="hljs-keyword">for</span> _, task := <span class="hljs-keyword">range</span> getTask(i) &#123;<br>ch &lt;- task<br>&#125;<br>i += numWorkers<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getTask</span><span class="hljs-params">(j <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">Task</span></span> &#123;<br>tasks := <span class="hljs-built_in">make</span>([]Task, <span class="hljs-number">0</span>, numWorkers)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; numWorkers; i++ &#123;<br>tasks = <span class="hljs-built_in">append</span>(tasks, Task&#123;num: j + i&#125;)<br>&#125;<br><span class="hljs-keyword">return</span> tasks<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> Task)</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// 接受任务并处理</span><br>task := &lt;-ch<br>process(task)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">process</span><span class="hljs-params">(task Task)</span></span> &#123;<br>fmt.Println(task.num)<br>&#125;<br><br><span class="hljs-keyword">type</span> Task <span class="hljs-keyword">struct</span> &#123;<br>num <span class="hljs-keyword">int</span><br>&#125;<br><span class="hljs-comment">// 运行结果：</span><br><span class="hljs-comment">// 每一秒打印随机打印10个数字，从1-10开始，11-20...</span><br></code></pre></td></tr></table></figure><h3 id="源码分析实现原理"><a href="#源码分析实现原理" class="headerlink" title="源码分析实现原理"></a>源码分析实现原理</h3><p>TODO</p><h2 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h2><h3 id="GMP模型"><a href="#GMP模型" class="headerlink" title="GMP模型"></a>GMP模型</h3><p>在Go的并发编程模型中，不受操作系统内核管理的独立控制流不叫用户线程或线程，而称为Goroutine。Goroutine通常被认为是协程的Go实现，实际上Goroutine并不是传统意义上的协程，传统的协程库属于用户级线程模型，而Goroutine结合Go调度器的底层实现上属于两级线程模型：</p><p><img src="/img/Golang%E5%B9%B6%E5%8F%91%E6%B5%85%E6%9E%90/image-20220129211534479.png" alt="image-20220129211534479"></p><p>用户线程与KSE是多对多关系(M:N)，两级线程模型既不是用户级线程模型那种完全靠自己调度的也不是内核级线程模型完全靠操作系统调度的，而是一种自身调度与系统调度协同工作的中间态，<strong>即用户调度器实现用户线程到KSE的调度，内核调度器实现KSE到CPU上的调度。</strong></p><p>Go搭建了一个特有的两级线程模型。由Go调度器实现Goroutine到KSE的调度，由内核调度器实现KSE到CPU上的调度。Go的调度器使用G、M、P三个结构体来实现Goroutine的调度，也称之为<strong>GMP模型</strong></p><p><img src="/img/Golang%E5%B9%B6%E5%8F%91%E6%B5%85%E6%9E%90/image-20220129163730476.png" alt="image-20220129163730476"></p><p>​    其中GMP都是runtime包下的结构体，分别用来抽象不同的实体：</p><ul><li>M代表操作系统线程，代表着真正执行计算的资源，由操作系统的调度器调度和管理。M结构体对象除了记录着工作线程的诸如栈的起止位置、当前正在执行的Goroutine以及是否空闲等等状态信息之外，还通过指针维持着与P结构体的实例对象之间的绑定关系</li><li>G代表goroutine，G存储Goroutine的运行堆栈、状态以及任务函数，可重用。当Goroutine被调离CPU时，调度器代码负责把CPU寄存器的值保存在G对象的成员变量之中，当Goroutine被调度起来运行时，调度器代码又负责把G对象的成员变量所保存的寄存器的值恢复到CPU的寄存器</li><li>P代表调度上下文，对G来说，P相当于CPU核，G只有绑定到P(在P的local runq中)才能被调度。对M来说，P提供了相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)等。它维护一个局部Goroutine可运行G队列，工作线程优先使用自己的局部运行队列，只有必要时才会去访问全局运行队列，这可以大大减少锁冲突，提高工作线程的并发性，并且可以良好的运用程序的局部性原理</li></ul><p><img src="/img/Golang%E5%B9%B6%E5%8F%91%E6%B5%85%E6%9E%90/image-20220129213206582.png" alt="image-20220129213206582"></p><h3 id="源码分析实现原理-1"><a href="#源码分析实现原理-1" class="headerlink" title="源码分析实现原理"></a>源码分析实现原理</h3><p>TODO</p><h3 id="一个Demo"><a href="#一个Demo" class="headerlink" title="一个Demo"></a>一个Demo</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> numWorkers = <span class="hljs-number">1000</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; numWorkers; i++ &#123;<br>fmt.Println(<span class="hljs-string">&quot;A:&quot;</span>, i)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; numWorkers; i++ &#123;<br>fmt.Println(<span class="hljs-string">&quot;B:&quot;</span>, i)<br>&#125;<br>&#125;<br><span class="hljs-comment">// A和B会同时交叉打印1-999，因为有两个goroutine在同时运行在两个操作系统线程M上，所以AB是有可能交替出现的</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>runtime.GOMAXPROCS(<span class="hljs-number">2</span>) <span class="hljs-comment">// 设置P的个数</span><br><span class="hljs-keyword">go</span> a()<br><span class="hljs-keyword">go</span> b()<br>time.Sleep(time.Second)<br>&#125;<br><span class="hljs-comment">// A和B会分别打印1-999，因为设置了一个P，只有一个操作系统线程供使用，故两个gouroutine同时只有一个能运行</span><br><span class="hljs-comment">// 只可能A或B先打印1-999，随后打印另外一个1-999，而不会出现AB交替的情况</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>runtime.GOMAXPROCS(<span class="hljs-number">1</span>) <span class="hljs-comment">// 设置P的个数</span><br><span class="hljs-keyword">go</span> a()<br><span class="hljs-keyword">go</span> b()<br>time.Sleep(time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><p>P的个数是通过<code>runtime.GOMAXPROCS</code>设定（最大256），Go1.5版本之后默认为CPU逻辑核心数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。</p><p>一般将P设置为CPU的逻辑线程数，可以最大化多核CPU的性能，同时减少内核级线程切换的开销</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">runtime.GOMAXPROCS(runtime.NumCPU())<br></code></pre></td></tr></table></figure><p>单从线程调度讲，像Java、C++等其他语言的多线程都是OS线程的抽象，是由OS内核来调度的。相比大多数并行设计模型，Go比较优势的设计就是P上下文这个概念的出现，如果只有G和M的对应关系，那么当G阻塞在IO上的时候，M是没有实际在工作的，这样造成了资源的浪费，没有了P，那么所有G的列表都放在全局，这样导致临界区太大，对多核调度造成极大影响。而Go语言的<code>goroutine</code>则是由Go的运行时（runtime）自己的调度器Saga调度的，这个调度器复用&#x2F;调度m个goroutine到n个OS线程。 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。</p><h2 id="Saga-scheduler"><a href="#Saga-scheduler" class="headerlink" title="Saga scheduler"></a>Saga scheduler</h2><p>TODO</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.youtube.com/watch?v=KBZlN0izeiY">https://www.youtube.com/watch?v=KBZlN0izeiY</a></p><p><a href="https://speakerdeck.com/kavya719/understanding-channels">https://speakerdeck.com/kavya719/understanding-channels</a></p><p><a href="https://www.jianshu.com/p/afe41fe1f672#comments">https://www.jianshu.com/p/afe41fe1f672#comments</a></p><p><a href="https://www.liwenzhou.com/posts/Go/14_concurrence/">https://www.liwenzhou.com/posts/Go/14_concurrence/</a></p><p><a href="https://www.youtube.com/watch?v=YHRO5WQGh0k">https://www.youtube.com/watch?v=YHRO5WQGh0k</a></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工作踩坑记录</title>
    <link href="/2021/11/17/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/11/17/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h4 id="工作踩坑记录"><a href="#工作踩坑记录" class="headerlink" title="工作踩坑记录"></a>工作踩坑记录</h4><h3 id="01-go截取字符串后乱码"><a href="#01-go截取字符串后乱码" class="headerlink" title="01 go截取字符串后乱码"></a>01 go截取字符串后乱码</h3><p>在做项目时，用到go string字符串的索引来截取字符串，截取后出现了乱码</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs go">str := <span class="hljs-string">&quot;深圳&quot;</span><br><br>str1 := str[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>]  <span class="hljs-comment">// 想截取出“深”但得到的是�</span><br></code></pre></td></tr></table></figure><p>经验证后发现，go语言中string底层是byte切片，中文字体用3byte存储，而英文和数字用1byte存储，通过索引切片的模式自然会截取出中文编码的一部分，因此造成乱码的结果</p><p><img src="/img/2021-11-17/image-20211117144416660.png" alt="image-20211117144416660"></p><p>解决方案：转成rune切片后索引操作</p><p><img src="/img/2021-11-17/image-20211117144924443.png" alt="image-20211117144924443"></p><h3 id="02-panic-runtime-error-invalid-memory-address-or-nil-pointer-dereference"><a href="#02-panic-runtime-error-invalid-memory-address-or-nil-pointer-dereference" class="headerlink" title="02 panic: runtime error: invalid memory address or nil pointer dereference"></a>02 panic: runtime error: invalid memory address or nil pointer dereference</h3><p>这个就类似于<code>java</code>中的空指针异常<code>NullPointerException</code>，在声明了指针变量之后未分配内存而直接使用</p><p><img src="/img/2021-11-17/image-20211117145707339.png" alt="image-20211117145707339"></p><p>解决办法：可以通过new操作来为对应的类型分配内存，并返回对应类型的指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">ptr = <span class="hljs-built_in">new</span>(<span class="hljs-keyword">int</span>)<br><span class="hljs-comment">// The new built-in function allocates memory. The first argument is a type,</span><br><span class="hljs-comment">// not a value, and the value returned is a pointer to a newly</span><br><span class="hljs-comment">// allocated zero value of that type.</span><br><span class="hljs-comment">// func new(Type) *Type</span><br></code></pre></td></tr></table></figure><p>在实际项目中，我们一般不对基本类型操作指针而是传值，对结构体使用指针较为多，但通过new的操作较少</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>stu := <span class="hljs-built_in">new</span>(Student)<br>stu.name = <span class="hljs-string">&quot;张三&quot;</span><br>fmt.Println(stu)<br><br>stu2 := &amp;Student&#123;name: <span class="hljs-string">&quot;李四&quot;</span>&#125; <span class="hljs-comment">// 实际工作中常用这种方式</span><br>fmt.Println(stu2)<br>&#125;<br><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-keyword">string</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="03-WaitGroup使用错误"><a href="#03-WaitGroup使用错误" class="headerlink" title="03 WaitGroup使用错误"></a>03 WaitGroup使用错误</h3><p>在一次做需求中，由于<code>doSomeThing()</code> 函数比较耗时，因此采用协程并发的方式运行，写出了如下代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">wg = &amp;sync.WaitGroup&#123;&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> sizeList &#123;<br>i := i<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>wg.Add(<span class="hljs-number">1</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-keyword">defer</span> wg.Done()<br>doSomeThing(i) <span class="hljs-comment">// 一些耗时操作</span><br>&#125;()<br>&#125;<br><br>wg.Wait() <span class="hljs-comment">// 2</span><br><span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>然而，程序并不会执行<code>len(sizeList)</code>次<code>doSomeThing()</code> 函数，原因在于<code>wg.Add(1)</code>写在了<code>go func()&#123;&#125;</code>内部，正确的写法如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">wg = &amp;sync.WaitGroup&#123;&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> sizeList &#123;<br>i := i<br>    wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>doSomeThing(i) <span class="hljs-comment">// 一些耗时操作</span><br>&#125;()<br>&#125;<br><br>wg.Wait()<br><span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>错误的写法中，可能主goroutine已经执行到了<code>wg.Waig()</code>而协程还没有启动，因此主线程会直接继续执行<code>wg.Waig()</code>后续的代码，从而使<code>wg.Waig()</code>失效</p><h3 id="04-panic-proto-message-data-collection-protos-PerformanceReq-is-already-registered"><a href="#04-panic-proto-message-data-collection-protos-PerformanceReq-is-already-registered" class="headerlink" title="04 panic: proto: message data_collection_protos.PerformanceReq is already registered"></a>04 panic: proto: message data_collection_protos.PerformanceReq is already registered</h3><p>原因是ugc_control服务中引用了utils服务，utils服务引用middlewares版本为v1.1.2，ugc_control服务中引用的最新版本，不同版本的middlewares导致 go 认为是两个包，从而重复注册两个data_collection_protos导致panic</p><p>解决：首先是按照网上的方法降级到指定的版本避免panic，但是这样做的话服务会不断的重启，只好从根源解决重复注册问题，将项目中通过其他服务间接用到的middlewares全部升级为最新版本</p><p><a href="https://developers.google.com/protocol-buffers/docs/reference/go/faq#namespace-conflict">https://developers.google.com/protocol-buffers/docs/reference/go/faq#namespace-conflict</a></p>]]></content>
    
    
    <categories>
      
      <category>Work</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>tencent</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>理解Golang中的[]interface{}和interface{}</title>
    <link href="/2021/07/28/%E7%90%86%E8%A7%A3Golang%E4%B8%AD%E7%9A%84-interface-%E5%92%8Cinterface/"/>
    <url>/2021/07/28/%E7%90%86%E8%A7%A3Golang%E4%B8%AD%E7%9A%84-interface-%E5%92%8Cinterface/</url>
    
    <content type="html"><![CDATA[<h4 id="理解Golang中的-interface-和interface"><a href="#理解Golang中的-interface-和interface" class="headerlink" title="理解Golang中的[]interface{}和interface{}"></a>理解<code>Golang</code>中的<code>[]interface&#123;&#125;</code>和<code>interface&#123;&#125;</code></h4><p>之前在开发Go项目操作Redis时，利用Do函数进行数据操作，在返回的<code>interface&#123;&#125;</code>类型的转换中踩了一个大坑。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs go">Do(ctx, <span class="hljs-string">&quot;HKEYS&quot;</span>, <span class="hljs-string">&quot;KEY&quot;</span>)<br></code></pre></td></tr></table></figure><p>在阅读源码中发现，Do方法的是一个<code>[]interface&#123;&#125;</code>切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Redis)</span> <span class="hljs-title">Do</span><span class="hljs-params">(ctx context.Context, commandName <span class="hljs-keyword">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, error)</span></span> &#123;<br><span class="hljs-comment">//</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">//</span><br>reply, err := conn.Do(commandName, args...)<br><span class="hljs-comment">//</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">//</span><br><span class="hljs-keyword">return</span> reply, c.err<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *conn)</span> <span class="hljs-title">Do</span><span class="hljs-params">(cmd <span class="hljs-keyword">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, error)</span></span> &#123;<br><span class="hljs-keyword">return</span> c.DoWithTimeout(c.readTimeout, cmd, args...)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *conn)</span> <span class="hljs-title">DoWithTimeout</span><span class="hljs-params">(readTimeout time.Duration, cmd <span class="hljs-keyword">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, error)</span></span> &#123;<br><span class="hljs-comment">//</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">//</span><br>reply := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">interface</span>&#123;&#125;, pending)<br><span class="hljs-comment">//</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">return</span> reply, err<br>&#125;<br></code></pre></td></tr></table></figure><p>在Goland中有一种特殊类型：<code>interface&#123;&#125;</code> ，<strong>空接口</strong>。<code>interface&#123;&#125;</code> 类型是没有方法的接口。由于没有 <code>implements</code> 关键字，所以所有类型都至少实现了 0 个方法，所以 <strong>所有类型都实现了空接口</strong>。这意味着，如果编写一个函数以 <code>interface&#123;&#125;</code> 值作为参数，那么可以为该函数提供任何值，并且，<code>[]interface&#123;&#125;</code>在<code>golang</code>中也可以认为是<code>interface&#123;&#125;</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>method(<span class="hljs-string">&quot;string&quot;</span>)<br>method(<span class="hljs-number">123</span>)<br>method(<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>))<br>method(<span class="hljs-built_in">make</span>([]<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-number">0</span>))<br>method(<span class="hljs-literal">true</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">method</span><span class="hljs-params">(arg <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>所以Do方法的返回值是<code>interface&#123;&#125;</code>类型，但本质上应该是<code>[]interface&#123;&#125;</code>类型，又因为redis的hkeys操作返回的是field字符串数组</p><p><img src="/img/2021-07-28/image-20210727231339355.png" alt="image-20210727231339355"></p><p>那么上述命令的返回值实际上应该是<code>[]string</code>或者<code>[]byte</code>类型，于是利用golang的类型判定，写出了如下代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a <span class="hljs-keyword">interface</span>&#123;&#125; = method()<br>bytes := a.([]<span class="hljs-keyword">byte</span>)<br>fmt.Println(bytes)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br>ans := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">append</span>(ans, []<span class="hljs-keyword">byte</span>&#123;<span class="hljs-number">96</span>, <span class="hljs-number">97</span>, <span class="hljs-number">98</span>, <span class="hljs-number">99</span>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>然而，编译器狠狠的打了我的脸</p><p><img src="/img/2021-07-28/image-20210727234046713.png" alt="image-20210727234046713"></p><p>既然<code>interface&#123;&#125;</code>能代表任意类型，那么<code>interface&#123;&#125;</code>的切片为什么不能代表任意类型的切片呢？</p><p>了解了相关底层数据存储原理后，这个问题也就迎刃而解了</p><p>一个<code>interface&#123;&#125;</code>类型的变量的底层存储结构由两个字word组成；一个字用于指向该值底层类型的方法表，另一个字用于指向实际数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> eface <span class="hljs-keyword">struct</span> &#123;<br>    _type *_type<br>    data  unsafe.Pointer<br>&#125;<br></code></pre></td></tr></table></figure><p>所以即使两个变量都是<code>interface&#123;&#125;</code>类型，但底层的类型不同，则两个变量不相等</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>a <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-number">123</span><br>b <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-string">&quot;string&quot;</span><br>)<br>fmt.Println(a == b) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>那么对于<code>[]interface&#123;&#125;</code>类型的变量来说，切片里的每个元素可以存储不同类型的变量，例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-number">0</span>)<br>a = <span class="hljs-built_in">append</span>(a, []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">123</span>, <span class="hljs-number">456</span>&#125;)<br>a = <span class="hljs-built_in">append</span>(a, []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;ijk&quot;</span>&#125;)<br>fmt.Println(a) <span class="hljs-comment">// [[123 456] [abc ijk]]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但即使切片里存的数据都是某个特定的类型，也不能通过类型断定来强制转换，因为底层的数据存储结构不同</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := method()<br>_, ok := a.([]<span class="hljs-keyword">int</span>)<br>fmt.Println(ok) <span class="hljs-comment">// false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-number">0</span>)<br>a = <span class="hljs-built_in">append</span>(a, []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">123</span>, <span class="hljs-number">456</span>&#125;)<br>a = <span class="hljs-built_in">append</span>(a, []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">789</span>, <span class="hljs-number">111</span>&#125;)<br><span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Each <code>interface&#123;&#125;</code> takes up two words (one word for the type of what is contained, the other word for either the contained data or a pointer to it). As a consequence, a slice with length N and with type <code>[]interface&#123;&#125;</code> is backed by a chunk of data that is N*2 words long.</p><p>This is different than the chunk of data backing a slice with type <code>[]MyType</code> and the same length. Its chunk of data will be N*sizeof(MyType) words long.</p><p>The result is that you cannot quickly assign something of type <code>[]MyType</code> to something of type <code>[]interface&#123;&#125;</code>; the data behind them just look different.</p></blockquote><p>那么如果我们要把同类型组成的切片转换成的特定类型，可以这样做</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := method()<br>ans := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)<br>b, ok := a.([]<span class="hljs-keyword">interface</span>&#123;&#125;)<br><span class="hljs-keyword">if</span> ok &#123;<br><span class="hljs-keyword">for</span> _, element := <span class="hljs-keyword">range</span> b &#123;<br>ans = <span class="hljs-built_in">append</span>(ans, element.([]<span class="hljs-keyword">int</span>))<br>&#125;<br>&#125;<br>fmt.Println(ans) <span class="hljs-comment">// [[123 456] [789 111]]</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-number">0</span>)<br>a = <span class="hljs-built_in">append</span>(a, []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">123</span>, <span class="hljs-number">456</span>&#125;)<br>a = <span class="hljs-built_in">append</span>(a, []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">789</span>, <span class="hljs-number">111</span>&#125;)<br><span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure><p>参考文章：</p><p><a href="https://github.com/golang/go/wiki/InterfaceSlice">InterfaceSlice · golang&#x2F;go Wiki (github.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>interface</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hello-world</title>
    <link href="/2021/06/23/hello-world/"/>
    <url>/2021/06/23/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Hello world!</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, world!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello,World&quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Hello, world!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout&lt;&lt;<span class="hljs-string">&quot;Hello,World&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
