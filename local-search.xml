<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>gin框架学习笔记</title>
    <link href="/2022/01/26/gin%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/01/26/gin%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Gin框架学习笔记"><a href="#Gin框架学习笔记" class="headerlink" title="Gin框架学习笔记"></a>Gin框架学习笔记</h1><blockquote><p>之前在QQ音乐实习的时候，一直用的是TEG那边写的going框架+TME在此基础上的封装，一直没能目睹Gin框架的真容，目前IEG所在组用的是Gin，正好学习一下优秀开源框架的设计思想，故记录此文</p></blockquote><blockquote><p><a href="https://gin-gonic.com/">https://gin-gonic.com/</a></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default()<br>r.GET(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;pong&quot;</span>,<br>&#125;)<br>&#125;)<br>r.Run() <span class="hljs-comment">// listen and serve on 0.0.0.0:8080</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-Gin-Middleware"><a href="#1-Gin-Middleware" class="headerlink" title="1. Gin Middleware"></a>1. Gin Middleware</h3><p>在学习项目源码的过程中，看到大量使用了中间件，比如统计某接口的耗时，进行登陆态校验，开启跨域函数等等，那么这个中间件是个什么东西？</p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><blockquote><h3 id="Middleware-support"><a href="#Middleware-support" class="headerlink" title="Middleware support"></a>Middleware support</h3><p>An incoming HTTP request can be handled by a chain of middlewares and the final action. For example: Logger, Authorization, GZIP and finally post a message in the DB.</p></blockquote><p>从Gin的官网介绍大概能得知中间件是一个可以处理HTTP请求的函数调用链，这类似与Java中的Filter过滤器或者是Spring中的Interceptor拦截器，可以统一在请求接口之前或之后执行我们定义的中间件。</p><blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">&gt;<span class="hljs-comment">// HandlerFunc defines the handler used by gin middleware as return value.</span><br>&gt;<span class="hljs-keyword">type</span> HandlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Context)</span></span><br><br>&gt;<span class="hljs-comment">// HandlersChain defines a HandlerFunc array.</span><br>&gt;<span class="hljs-keyword">type</span> HandlersChain []HandlerFunc<br></code></pre></td></tr></table></figure></blockquote><h4 id="用例Demo"><a href="#用例Demo" class="headerlink" title="用例Demo"></a>用例Demo</h4><p>了解了基本的概念之后，如何使用？开发文档提供了如下Demo</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Logger</span><span class="hljs-params">()</span> <span class="hljs-title">gin</span>.<span class="hljs-title">HandlerFunc</span></span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>t := time.Now()<br><span class="hljs-comment">// Set example variable</span><br>c.Set(<span class="hljs-string">&quot;example&quot;</span>, <span class="hljs-string">&quot;12345&quot;</span>)<br><span class="hljs-comment">// before request</span><br><br>c.Next()<br><br><span class="hljs-comment">// after request</span><br>latency := time.Since(t)<br>log.Print(latency)<br><span class="hljs-comment">// access the status we are sending</span><br>status := c.Writer.Status()<br>log.Println(status)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.New()<br>r.Use(Logger()) <span class="hljs-comment">// 注册中间件</span><br>r.GET(<span class="hljs-string">&quot;/test&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;  <span class="hljs-comment">// 注册/test接口对应的执行方法</span><br>example := c.MustGet(<span class="hljs-string">&quot;example&quot;</span>).(<span class="hljs-keyword">string</span>)<br><span class="hljs-comment">// it would print: &quot;12345&quot;</span><br>log.Println(example)<br>&#125;)<br><span class="hljs-comment">// Listen and serve on 0.0.0.0:8080</span><br>r.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl --location --request GET &#x27;http://localhost:8080/test&#x27;<br>2022/01/26 17:38:34 12345<br>2022/01/26 17:38:34 140.807µs<br>2022/01/26 17:38:34 200<br></code></pre></td></tr></table></figure><p>可以看到，在注册了<code>Logger()</code>中间件后，依次是打印了<code>example</code>、<code>latency</code>和<code>status</code>三个变量的值。</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Use attaches a global middleware to the router. ie. the middleware attached though Use() will be</span><br><span class="hljs-comment">// included in the handlers chain for every single request. Even 404, 405, static files...</span><br><span class="hljs-comment">// For example, this is the right place for a logger or error management middleware.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span> <span class="hljs-title">Use</span><span class="hljs-params">(middleware ...HandlerFunc)</span> <span class="hljs-title">IRoutes</span></span> &#123;<br>engine.RouterGroup.Use(middleware...)<br>engine.rebuild404Handlers()<br>engine.rebuild405Handlers()<br><span class="hljs-keyword">return</span> engine<br>&#125;<br><br><span class="hljs-comment">// Use adds middleware to the group, see example code in GitHub.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span> <span class="hljs-title">Use</span><span class="hljs-params">(middleware ...HandlerFunc)</span> <span class="hljs-title">IRoutes</span></span> &#123;<br>group.Handlers = <span class="hljs-built_in">append</span>(group.Handlers, middleware...) <span class="hljs-comment">// 将多个中间件添加到group.Handlers也就是slice中</span><br><span class="hljs-keyword">return</span> group.returnObj()<br>&#125;<br><br><span class="hljs-comment">// RouterGroup is used internally to configure router, a RouterGroup is associated with</span><br><span class="hljs-comment">// a prefix and an array of handlers (middleware).</span><br><span class="hljs-keyword">type</span> RouterGroup <span class="hljs-keyword">struct</span> &#123;<br>Handlers HandlersChain<br>basePath <span class="hljs-keyword">string</span><br>engine   *Engine<br>root     <span class="hljs-keyword">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，<code>Use()</code>将多个中间件函数注册到RouterGroup这个结构体中的HandlersChain slice中</p><p>再来看<code>Get()</code>是如何执行并访问到注册的接口的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// GET is a shortcut for router.Handle(&quot;GET&quot;, path, handle).</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span> <span class="hljs-title">GET</span><span class="hljs-params">(relativePath <span class="hljs-keyword">string</span>, handlers ...HandlerFunc)</span> <span class="hljs-title">IRoutes</span></span> &#123;<br><span class="hljs-keyword">return</span> group.handle(http.MethodGet, relativePath, handlers)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span> <span class="hljs-title">handle</span><span class="hljs-params">(httpMethod, relativePath <span class="hljs-keyword">string</span>, handlers HandlersChain)</span> <span class="hljs-title">IRoutes</span></span> &#123;<br>absolutePath := group.calculateAbsolutePath(relativePath) <span class="hljs-comment">// 绝对地址</span><br>handlers = group.combineHandlers(handlers) <span class="hljs-comment">// 将注册的func合并到HandlersChain中</span><br>group.engine.addRoute(httpMethod, absolutePath, handlers)<br><span class="hljs-keyword">return</span> group.returnObj()<br>&#125;<br><br><span class="hljs-keyword">const</span> abortIndex <span class="hljs-keyword">int8</span> = math.MaxInt8 / <span class="hljs-number">2</span> <span class="hljs-comment">// =63</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span> <span class="hljs-title">combineHandlers</span><span class="hljs-params">(handlers HandlersChain)</span> <span class="hljs-title">HandlersChain</span></span> &#123;<br>finalSize := <span class="hljs-built_in">len</span>(group.Handlers) + <span class="hljs-built_in">len</span>(handlers) <span class="hljs-comment">// HandlersChain已有的HandlerFunc + 当前要添加的HandlerFunc的长度大于最大长度则panic</span><br><span class="hljs-keyword">if</span> finalSize &gt;= <span class="hljs-keyword">int</span>(abortIndex) &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;too many handlers&quot;</span>)<br>&#125;<br>mergedHandlers := <span class="hljs-built_in">make</span>(HandlersChain, finalSize)<br><span class="hljs-built_in">copy</span>(mergedHandlers, group.Handlers) <span class="hljs-comment">// copy原有的HandlerFunc到新的slice mergedHandlers</span><br><span class="hljs-built_in">copy</span>(mergedHandlers[<span class="hljs-built_in">len</span>(group.Handlers):], handlers) <span class="hljs-comment">// copy新增的HandlerFunc</span><br><span class="hljs-keyword">return</span> mergedHandlers<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，在像Demo中调用的那样之后，HandlersChain 会形成这样一个Slice，里面的HandlerFunc是依次顺序执行的。</p><p><img src="/img/2022-01-26/image-20220126195307202.png"></p><p>再来看<code>Next()</code>，实现原理很简单，首先是index指针自增1，随后进入一个死循环，依次执行HandlersChain Slice中的下一个HandlerFunc直到最后</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Next should be used only inside middleware.</span><br><span class="hljs-comment">// It executes the pending handlers in the chain inside the calling handler.</span><br><span class="hljs-comment">// See example in GitHub.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span> <span class="hljs-title">Next</span><span class="hljs-params">()</span></span> &#123;<br>c.index++<br><span class="hljs-keyword">for</span> c.index &lt; <span class="hljs-keyword">int8</span>(<span class="hljs-built_in">len</span>(c.handlers)) &#123; <span class="hljs-comment">// 死循环</span><br>c.handlers[c.index](c) <span class="hljs-comment">// 执行HandlersChain Slice中下一个HandlerFunc</span><br>c.index++<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以Demo中代码首先执行<code>Logger()</code>，在设置完example中的值之后调用了<code>Next()</code>从而执行main.main.func1，最后再回到main.Logger.func1执行3和4</p><p><img src="/img/2022-01-26/image-20220126195826399.png" alt="image-20220126195826399"></p><h4 id="踩坑点"><a href="#踩坑点" class="headerlink" title="踩坑点"></a>踩坑点</h4><p>需要注意的是，<code>Use()</code>需要在<code>Get() Post()...</code>之类的方法之前调用，否则HandlersChain中只会有<code>Use()</code>添加的中间件而不会有<code>Get() Post()...</code>添加的接口执行函数，因为只有在<code>handle()</code>方法中才会进行HandlersChain的copy和append</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.New()<br>r.Use(TimeExpend)<br>r.GET(<span class="hljs-string">&quot;/ping&quot;</span>, f1, process, f2, f3)<br>r.Run() <span class="hljs-comment">// listen and serve on 0.0.0.0:8080 (for windows &quot;localhost:8080&quot;)</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TimeExpend</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>t := time.Now()<br>c.Next()<br>fmt.Println(time.Since(t))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">process</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;process&quot;</span>)<br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;pong&quot;</span>,<br>&#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f1</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;f1&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f2</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;f2&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f3</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;f3&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 执行链条 TimeExpend记录开始时间-&gt;f1-&gt;process-&gt;f2-&gt;f3-&gt;TimeExpend打印耗时</span><br><span class="hljs-comment">// 输出结果:</span><br><span class="hljs-comment">// f1</span><br><span class="hljs-comment">// process</span><br><span class="hljs-comment">// f2</span><br><span class="hljs-comment">// f3</span><br><span class="hljs-comment">// 106.441µs</span><br></code></pre></td></tr></table></figure><p><img src="/img/2022-01-26/image-20220126224500983.png" alt="image-20220126224500983"></p><p>end</p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工作踩坑记录</title>
    <link href="/2021/11/17/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/11/17/%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h4 id="工作踩坑记录"><a href="#工作踩坑记录" class="headerlink" title="工作踩坑记录"></a>工作踩坑记录</h4><h3 id="01-go截取字符串后乱码"><a href="#01-go截取字符串后乱码" class="headerlink" title="01 go截取字符串后乱码"></a>01 go截取字符串后乱码</h3><p>在做项目时，用到go string字符串的索引来截取字符串，截取后出现了乱码</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs go">str := <span class="hljs-string">&quot;深圳&quot;</span><br><br>str1 := str[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>]  <span class="hljs-comment">// 想截取出“深”但得到的是�</span><br></code></pre></td></tr></table></figure><p>经验证后发现，go语言中string底层是byte切片，中文字体用3byte存储，而英文和数字用1byte存储，通过索引切片的模式自然会截取出中文编码的一部分，因此造成乱码的结果</p><p><img src="/img/2021-11-17/image-20211117144416660.png" alt="image-20211117144416660"></p><p>解决方案：转成rune切片后索引操作</p><p><img src="/img/2021-11-17/image-20211117144924443.png" alt="image-20211117144924443"></p><h3 id="02-panic-runtime-error-invalid-memory-address-or-nil-pointer-dereference"><a href="#02-panic-runtime-error-invalid-memory-address-or-nil-pointer-dereference" class="headerlink" title="02 panic: runtime error: invalid memory address or nil pointer dereference"></a>02 panic: runtime error: invalid memory address or nil pointer dereference</h3><p>这个就类似于<code>java</code>中的空指针异常<code>NullPointerException</code>，在声明了指针变量之后未分配内存而直接使用</p><p><img src="/img/2021-11-17/image-20211117145707339.png" alt="image-20211117145707339"></p><p>解决办法：可以通过new操作来为对应的类型分配内存，并返回对应类型的指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">ptr = <span class="hljs-built_in">new</span>(<span class="hljs-keyword">int</span>)<br><span class="hljs-comment">// The new built-in function allocates memory. The first argument is a type,</span><br><span class="hljs-comment">// not a value, and the value returned is a pointer to a newly</span><br><span class="hljs-comment">// allocated zero value of that type.</span><br><span class="hljs-comment">// func new(Type) *Type</span><br></code></pre></td></tr></table></figure><p>在实际项目中，我们一般不对基本类型操作指针而是传值，对结构体使用指针较为多，但通过new的操作较少</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>stu := <span class="hljs-built_in">new</span>(Student)<br>stu.name = <span class="hljs-string">&quot;张三&quot;</span><br>fmt.Println(stu)<br><br>stu2 := &amp;Student&#123;name: <span class="hljs-string">&quot;李四&quot;</span>&#125; <span class="hljs-comment">// 实际工作中常用这种方式</span><br>fmt.Println(stu2)<br>&#125;<br><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-keyword">string</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="03-WaitGroup使用错误"><a href="#03-WaitGroup使用错误" class="headerlink" title="03 WaitGroup使用错误"></a>03 WaitGroup使用错误</h3><p>在一次做需求中，由于<code>doSomeThing()</code> 函数比较耗时，因此采用协程并发的方式运行，写出了如下代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">wg = &amp;sync.WaitGroup&#123;&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> sizeList &#123;<br>i := i<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>wg.Add(<span class="hljs-number">1</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-keyword">defer</span> wg.Done()<br>doSomeThing(i) <span class="hljs-comment">// 一些耗时操作</span><br>&#125;()<br>&#125;<br><br>wg.Wait() <span class="hljs-comment">// 2</span><br><span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>然而，程序并不会执行<code>len(sizeList)</code>次<code>doSomeThing()</code> 函数，原因在于<code>wg.Add(1)</code>写在了<code>go func()&#123;&#125;</code>内部，正确的写法如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">wg = &amp;sync.WaitGroup&#123;&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> sizeList &#123;<br>i := i<br>    wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>doSomeThing(i) <span class="hljs-comment">// 一些耗时操作</span><br>&#125;()<br>&#125;<br><br>wg.Wait()<br><span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>错误的写法中，可能主goroutine已经执行到了<code>wg.Waig()</code>而协程还没有启动，因此主线程会直接继续执行<code>wg.Waig()</code>后续的代码，从而使<code>wg.Waig()</code>失效</p>]]></content>
    
    
    <categories>
      
      <category>Work</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>tencent</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>理解Golang中的[]interface{}和interface{}</title>
    <link href="/2021/07/28/%E7%90%86%E8%A7%A3Golang%E4%B8%AD%E7%9A%84-interface-%E5%92%8Cinterface/"/>
    <url>/2021/07/28/%E7%90%86%E8%A7%A3Golang%E4%B8%AD%E7%9A%84-interface-%E5%92%8Cinterface/</url>
    
    <content type="html"><![CDATA[<h4 id="理解Golang中的-interface-和interface"><a href="#理解Golang中的-interface-和interface" class="headerlink" title="理解Golang中的[]interface{}和interface{}"></a>理解<code>Golang</code>中的<code>[]interface&#123;&#125;</code>和<code>interface&#123;&#125;</code></h4><p>之前在开发Go项目操作Redis时，利用Do函数进行数据操作，在返回的<code>interface&#123;&#125;</code>类型的转换中踩了一个大坑。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs go">Do(ctx, <span class="hljs-string">&quot;HKEYS&quot;</span>, <span class="hljs-string">&quot;KEY&quot;</span>)<br></code></pre></td></tr></table></figure><p>在阅读源码中发现，Do方法的是一个<code>[]interface&#123;&#125;</code>切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Redis)</span> <span class="hljs-title">Do</span><span class="hljs-params">(ctx context.Context, commandName <span class="hljs-keyword">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, error)</span></span> &#123;<br><span class="hljs-comment">//</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">//</span><br>reply, err := conn.Do(commandName, args...)<br><span class="hljs-comment">//</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">//</span><br><span class="hljs-keyword">return</span> reply, c.err<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *conn)</span> <span class="hljs-title">Do</span><span class="hljs-params">(cmd <span class="hljs-keyword">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, error)</span></span> &#123;<br><span class="hljs-keyword">return</span> c.DoWithTimeout(c.readTimeout, cmd, args...)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *conn)</span> <span class="hljs-title">DoWithTimeout</span><span class="hljs-params">(readTimeout time.Duration, cmd <span class="hljs-keyword">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, error)</span></span> &#123;<br><span class="hljs-comment">//</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">//</span><br>reply := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">interface</span>&#123;&#125;, pending)<br><span class="hljs-comment">//</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">return</span> reply, err<br>&#125;<br></code></pre></td></tr></table></figure><p>在Goland中有一种特殊类型：<code>interface&#123;&#125;</code> ，<strong>空接口</strong>。<code>interface&#123;&#125;</code> 类型是没有方法的接口。由于没有 <code>implements</code> 关键字，所以所有类型都至少实现了 0 个方法，所以 <strong>所有类型都实现了空接口</strong>。这意味着，如果编写一个函数以 <code>interface&#123;&#125;</code> 值作为参数，那么可以为该函数提供任何值，并且，<code>[]interface&#123;&#125;</code>在<code>golang</code>中也可以认为是<code>interface&#123;&#125;</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>method(<span class="hljs-string">&quot;string&quot;</span>)<br>method(<span class="hljs-number">123</span>)<br>method(<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>))<br>method(<span class="hljs-built_in">make</span>([]<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-number">0</span>))<br>method(<span class="hljs-literal">true</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">method</span><span class="hljs-params">(arg <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>所以Do方法的返回值是<code>interface&#123;&#125;</code>类型，但本质上应该是<code>[]interface&#123;&#125;</code>类型，又因为redis的hkeys操作返回的是field字符串数组</p><p><img src="/img/2021-07-28/image-20210727231339355.png" alt="image-20210727231339355"></p><p>那么上述命令的返回值实际上应该是<code>[]string</code>或者<code>[]byte</code>类型，于是利用golang的类型判定，写出了如下代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a <span class="hljs-keyword">interface</span>&#123;&#125; = method()<br>bytes := a.([]<span class="hljs-keyword">byte</span>)<br>fmt.Println(bytes)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br>ans := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">append</span>(ans, []<span class="hljs-keyword">byte</span>&#123;<span class="hljs-number">96</span>, <span class="hljs-number">97</span>, <span class="hljs-number">98</span>, <span class="hljs-number">99</span>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>然而，编译器狠狠的打了我的脸</p><p><img src="/img/2021-07-28/image-20210727234046713.png" alt="image-20210727234046713"></p><p>既然<code>interface&#123;&#125;</code>能代表任意类型，那么<code>interface&#123;&#125;</code>的切片为什么不能代表任意类型的切片呢？</p><p>了解了相关底层数据存储原理后，这个问题也就迎刃而解了</p><p>一个<code>interface&#123;&#125;</code>类型的变量的底层存储结构由两个字word组成；一个字用于指向该值底层类型的方法表，另一个字用于指向实际数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> eface <span class="hljs-keyword">struct</span> &#123;<br>    _type *_type<br>    data  unsafe.Pointer<br>&#125;<br></code></pre></td></tr></table></figure><p>所以即使两个变量都是<code>interface&#123;&#125;</code>类型，但底层的类型不同，则两个变量不相等</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>a <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-number">123</span><br>b <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-string">&quot;string&quot;</span><br>)<br>fmt.Println(a == b) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>那么对于<code>[]interface&#123;&#125;</code>类型的变量来说，切片里的每个元素可以存储不同类型的变量，例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-number">0</span>)<br>a = <span class="hljs-built_in">append</span>(a, []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">123</span>, <span class="hljs-number">456</span>&#125;)<br>a = <span class="hljs-built_in">append</span>(a, []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;ijk&quot;</span>&#125;)<br>fmt.Println(a) <span class="hljs-comment">// [[123 456] [abc ijk]]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但即使切片里存的数据都是某个特定的类型，也不能通过类型断定来强制转换，因为底层的数据存储结构不同</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := method()<br>_, ok := a.([]<span class="hljs-keyword">int</span>)<br>fmt.Println(ok) <span class="hljs-comment">// false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-number">0</span>)<br>a = <span class="hljs-built_in">append</span>(a, []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">123</span>, <span class="hljs-number">456</span>&#125;)<br>a = <span class="hljs-built_in">append</span>(a, []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">789</span>, <span class="hljs-number">111</span>&#125;)<br><span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Each <code>interface&#123;&#125;</code> takes up two words (one word for the type of what is contained, the other word for either the contained data or a pointer to it). As a consequence, a slice with length N and with type <code>[]interface&#123;&#125;</code> is backed by a chunk of data that is N*2 words long.</p><p>This is different than the chunk of data backing a slice with type <code>[]MyType</code> and the same length. Its chunk of data will be N*sizeof(MyType) words long.</p><p>The result is that you cannot quickly assign something of type <code>[]MyType</code> to something of type <code>[]interface&#123;&#125;</code>; the data behind them just look different.</p></blockquote><p>那么如果我们要把同类型组成的切片转换成的特定类型，可以这样做</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := method()<br>ans := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)<br>b, ok := a.([]<span class="hljs-keyword">interface</span>&#123;&#125;)<br><span class="hljs-keyword">if</span> ok &#123;<br><span class="hljs-keyword">for</span> _, element := <span class="hljs-keyword">range</span> b &#123;<br>ans = <span class="hljs-built_in">append</span>(ans, element.([]<span class="hljs-keyword">int</span>))<br>&#125;<br>&#125;<br>fmt.Println(ans) <span class="hljs-comment">// [[123 456] [789 111]]</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-number">0</span>)<br>a = <span class="hljs-built_in">append</span>(a, []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">123</span>, <span class="hljs-number">456</span>&#125;)<br>a = <span class="hljs-built_in">append</span>(a, []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">789</span>, <span class="hljs-number">111</span>&#125;)<br><span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure><p>参考文章：</p><p><a href="https://github.com/golang/go/wiki/InterfaceSlice">InterfaceSlice · golang/go Wiki (github.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>interface</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hello-world</title>
    <link href="/2021/06/23/hello-world/"/>
    <url>/2021/06/23/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Hello world!</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, world!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello,World&quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Hello, world!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout&lt;&lt;<span class="hljs-string">&quot;Hello,World&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
